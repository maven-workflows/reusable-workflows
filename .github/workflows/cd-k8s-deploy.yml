name: Deploy to Container Apps

# Este workflow pode ser chamado por outro workflow (workflow_call)
on:
  workflow_call:
    secrets:
      AZURE_CREDENTIALS:
        description: 'JSON do Service Principal para fazer login no Azure'
        required: true

# Variáveis de ambiente padrão (podem ser sobrescritas pelo workflow chamador, se necessário)
env:
  ARTIFACT_NAME: "app-jar"                     # Nome do artifact que contém o JAR
  RESOURCE_GROUP: "azure-for-github-actions"   # Resource Group onde residem os recursos
  ACR_NAME: "ghactions"                        # Nome do Azure Container Registry (sem o .azurecr.io)
  DEFAULT_ENV_NAME: "ghactions-env"            # Nome do Container Apps Environment (caso precise criar)
  CA_NAME: "ghactions-ca"                      # Nome do Container App
  IMAGE_NAME: "demo-api"                       # Nome lógico da imagem (antes da tag)
  LOCATION: "eastus2"                          # Região onde os recursos residem

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # ------------------------------------------------------
      # 1) Download do JAR que foi publicado como artifact no build
      # ------------------------------------------------------
      - name: Download JAR Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ./app-jar

      # ------------------------------------------------------
      # 2) Login no Azure (Service Principal via JSON)
      # ------------------------------------------------------
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # ------------------------------------------------------
      # 3) Debug (opcional): exibe AZURE_CLIENT_ID para confirmar login
      # ------------------------------------------------------
      - name: mostrar variáveis de login
        run: |
          echo "AZURE_CLIENT_ID:     $AZURE_CLIENT_ID"
          echo "AZURE_SUBSCRIPTION_ID: $AZURE_SUBSCRIPTION_ID"
          echo "AZURE_TENANT_ID:     $AZURE_TENANT_ID"

      # ------------------------------------------------------
      # 4) Concede ao SP a role AcrPull no ACR (se ainda não existir)
      #    Tudo via CLI, sem precisar mexer no Portal
      # ------------------------------------------------------
      - name: Grant SP “AcrPull” on ACR (se necessário)
        run: |
          # 1) Descobre o objectId do Service Principal que acabou de fazer login
          SP_OBJECT_ID=$(
            az ad sp show --id "$AZURE_CLIENT_ID" --query objectId -o tsv
          )
          echo "objectId do SP: $SP_OBJECT_ID"

          # 2) Descobre o resourceId do ACR
          ACR_RESOURCE_ID=$(
            az acr show \
              --name "${{ env.ACR_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --query id -o tsv
          )
          echo "resourceId do ACR: $ACR_RESOURCE_ID"

          # 3) Verifica se já existe role assignment “AcrPull” para este SP sobre esse ACR
          EXISTS=$(
            az role assignment list \
              --assignee-object-id "$SP_OBJECT_ID" \
              --scope "$ACR_RESOURCE_ID" \
              --query "[?roleDefinitionName=='AcrPull'] | length(@)" -o tsv
          )

          if [ "$EXISTS" -eq "0" ]; then
            echo "SP não possui AcrPull sobre o ACR. Criando role assignment..."
            az role assignment create \
              --assignee-object-id "$SP_OBJECT_ID" \
              --role "AcrPull" \
              --scope "$ACR_RESOURCE_ID"
          else
            echo "SP já tem AcrPull sobre o ACR. Pulando esta etapa."
          fi

      # ------------------------------------------------------
      # 5) Criar Dockerfile dinamicamente, copiando o JAR baixado
      # ------------------------------------------------------
      - name: Criar Dockerfile
        run: |
          cat << 'EOF' > Dockerfile
          FROM openjdk:11-jre-slim
          COPY app-jar/*.jar /app.jar
          WORKDIR /
          EXPOSE 8080
          ENTRYPOINT ["java", "-jar", "/app.jar"]
          EOF

      # ------------------------------------------------------
      # 6) Build & Push da imagem Docker para o ACR
      # ------------------------------------------------------
      - name: Build & Push Docker Image
        run: |
          echo "Conteúdo de ./app-jar:"
          ls -l ./app-jar
          echo "Conteúdo da raiz (Dockerfile):"
          ls -l .

          IMAGE_FULL="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"

          # 1) Build da imagem
          docker build \
            -f Dockerfile \
            -t "$IMAGE_FULL" \
            .

          # 2) Login no ACR (o SP já tem AcrPull/AcrPush)
          az acr login --name "${{ env.ACR_NAME }}"

          # 3) Push da imagem para o ACR
          docker push "$IMAGE_FULL"

      # ------------------------------------------------------
      # 7) Criar Log Analytics Workspace (se ainda não existir)
      # ------------------------------------------------------
      - name: Create Log Analytics Workspace (if not exists)
        run: |
          az monitor log-analytics workspace create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --workspace-name ${{ env.DEFAULT_ENV_NAME }}-logs \
            --location ${{ env.LOCATION }}

      # ------------------------------------------------------
      # 8) Obter Customer ID e Shared Key do Log Analytics
      #    (para anexar ao Container Apps Environment)
      # ------------------------------------------------------
      - name: Get Log Analytics Workspace Customer ID and Key
        id: get-logs-info
        run: |
          LOGWS_CUSTOMER_ID=$(
            az monitor log-analytics workspace show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --workspace-name ${{ env.DEFAULT_ENV_NAME }}-logs \
              --query customerId -o tsv
          )
          LOGWS_KEY=$(
            az monitor log-analytics workspace get-shared-keys \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --workspace-name ${{ env.DEFAULT_ENV_NAME }}-logs \
              --query primarySharedKey -o tsv
          )

          echo "LOGWS_CUSTOMER_ID=$LOGWS_CUSTOMER_ID" >> "$GITHUB_OUTPUT"
          echo "LOGWS_KEY=$LOGWS_KEY" >> "$GITHUB_OUTPUT"

      # ------------------------------------------------------
      # 9) Descobrir se há Container Apps Environment no RG
      #    Se não houver, cria um novo com logs apontando para o Log Analytics
      # ------------------------------------------------------
      - name: Find or Create Container Apps Environment
        id: find_or_create_env
        run: |
          EXISTING=$(
            az containerapp env list \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "[0].name" -o tsv
          )

          if [ -z "$EXISTING" ] || [ "$EXISTING" == "None" ]; then
            echo "Nenhum Container Apps Environment encontrado; criando ${{ env.DEFAULT_ENV_NAME }}..."
            az containerapp env create \
              --name ${{ env.DEFAULT_ENV_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --logs-workspace-id "${{ steps.get-logs-info.outputs.LOGWS_CUSTOMER_ID }}" \
              --logs-workspace-key "${{ steps.get-logs-info.outputs.LOGWS_KEY }}"

            echo "::set-output name=env_name::${{ env.DEFAULT_ENV_NAME }}"
          else
            echo "Encontrado Container Apps Environment existente: $EXISTING"
            echo "::set-output name=env_name::$EXISTING"
          fi

      # ------------------------------------------------------
      # 10) Criar ou Atualizar o Container App,
      #     apontando apenas para o registry-server (ACR)
      #     O SP autenticado já tem permissão AcrPull para puxar a imagem
      # ------------------------------------------------------
      - name: Create or Update Container App
        run: |
          FINAL_ENV="${{ steps.find_or_create_env.outputs.env_name }}"
          ACR_LOGIN_SERVER="${{ env.ACR_NAME }}.azurecr.io"
          IMAGE_FULL="$ACR_LOGIN_SERVER/${{ env.IMAGE_NAME }}:${{ github.sha }}"

          if ! az containerapp show \
               --name "${{ env.CA_NAME }}" \
               --resource-group "${{ env.RESOURCE_GROUP }}" \
             > /dev/null 2>&1; then
            echo "Criando Container App '${{ env.CA_NAME }}' no Environment '$FINAL_ENV'..."
            az containerapp create \
              --name "${{ env.CA_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --environment "$FINAL_ENV" \
              --image "$IMAGE_FULL" \
              --ingress external \
              --target-port 8080 \
              --min-replicas 0 \
              --max-replicas 2 \
              --registry-server "$ACR_LOGIN_SERVER"
          else
            echo "Atualizando Container App '${{ env.CA_NAME }}' para usar a imagem mais recente..."
            az containerapp update \
              --name "${{ env.CA_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --environment "$FINAL_ENV" \
              --image "$IMAGE_FULL" \
              --registry-server "$ACR_LOGIN_SERVER"
          fi
